Directory structure:
└── SpaceTime/
    ├── README.md
    ├── CMakeLists.txt
    ├── example/
    ├── external/
    └── src/
        ├── CelestialBody.cpp
        ├── CelestialBody.h
        ├── GravityWell.cpp
        ├── GravityWell.h
        ├── PhysicsEngine.cpp
        ├── PhysicsEngine.h
        ├── Renderer.cpp
        ├── Renderer.h
        ├── main.cpp
        ├── raii.h
        ├── shaders/
        │   ├── fragment.glsl
        │   ├── gravity_well.comp.glsl
        │   ├── gravitywell.frag
        │   ├── gravitywell.vert
        │   ├── trail.frag
        │   ├── trail.vert
        │   └── vertex.glsl
        └── textures/
            ├── AngerBeta.webp
            ├── lava.webp
            └── stone.webp

================================================
File: README.md
================================================
# SpaceTime



================================================
File: CMakeLists.txt
================================================

cmake_minimum_required(VERSION 3.16)
project(SpaceTimeCube)

set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

include(FetchContent)

# ───── GLFW ─────
FetchContent_Declare(
  glfw
  GIT_REPOSITORY https://github.com/glfw/glfw.git
  GIT_TAG latest
)
FetchContent_MakeAvailable(glfw)

# ───── GLM ─────
FetchContent_Declare(
  glm
  GIT_REPOSITORY https://github.com/g-truc/glm.git
  GIT_TAG 0.9.9.8
)
FetchContent_MakeAvailable(glm)

# ───── ImGui ─────
FetchContent_Declare(
  imgui
  GIT_REPOSITORY https://github.com/ocornut/imgui.git
  GIT_TAG master
)
FetchContent_MakeAvailable(imgui)

# ───── OpenGL ─────
find_package(OpenGL REQUIRED)

set(SRC_DIR      ${CMAKE_SOURCE_DIR}/src)
set(EXTERNAL_DIR ${CMAKE_SOURCE_DIR}/external)

set(SRC_FILES
    ${SRC_DIR}/main.cpp
    ${SRC_DIR}/CelestialBody.cpp
    ${SRC_DIR}/PhysicsEngine.cpp
    ${SRC_DIR}/Renderer.cpp
    ${SRC_DIR}/GravityWell.cpp
    ${EXTERNAL_DIR}/glad/glad.c
)

# ───── ImGui Sources ─────
set(IMGUI_SOURCES
    ${imgui_SOURCE_DIR}/imgui.cpp
    ${imgui_SOURCE_DIR}/imgui_demo.cpp
    ${imgui_SOURCE_DIR}/imgui_draw.cpp
    ${imgui_SOURCE_DIR}/imgui_tables.cpp
    ${imgui_SOURCE_DIR}/imgui_widgets.cpp
    ${imgui_SOURCE_DIR}/backends/imgui_impl_glfw.cpp
    ${imgui_SOURCE_DIR}/backends/imgui_impl_opengl3.cpp
)

add_library(imgui STATIC ${IMGUI_SOURCES})

target_include_directories(imgui PUBLIC
    ${imgui_SOURCE_DIR}
    ${imgui_SOURCE_DIR}/backends
)

target_link_libraries(imgui PRIVATE glfw)

add_executable(SpaceTimeCube ${SRC_FILES})

target_include_directories(SpaceTimeCube PRIVATE
    ${SRC_DIR}
    ${EXTERNAL_DIR}
    ${glm_SOURCE_DIR}
    ${imgui_SOURCE_DIR}
    ${imgui_SOURCE_DIR}/backends
)

target_link_libraries(SpaceTimeCube PRIVATE
    glfw
    imgui
    OpenGL::GL
    glm::glm
)

target_compile_definitions(SpaceTimeCube PRIVATE GLFW_INCLUDE_NONE)



file(GLOB_RECURSE SHADERS
     "${SRC_DIR}/shaders/*.vert"
     "${SRC_DIR}/shaders/*.frag"
     "${SRC_DIR}/shaders/*.comp"
)
file(GLOB_RECURSE TEXTURES
     "${SRC_DIR}/textures/*"
)

add_custom_target(copy-assets ALL
    DEPENDS ${SHADERS} ${TEXTURES}
    COMMAND ${CMAKE_COMMAND} -E copy_directory
            ${SRC_DIR}/shaders
            ${CMAKE_CURRENT_BINARY_DIR}/shaders
    COMMAND ${CMAKE_COMMAND} -E copy_directory
            ${SRC_DIR}/textures
            ${CMAKE_CURRENT_BINARY_DIR}/textures
)

add_dependencies(SpaceTimeCube copy-assets)






================================================
File: src/CelestialBody.cpp
================================================
#include "CelestialBody.h"
#include "raii.h"

#define STB_IMAGE_IMPLEMENTATION
#include <stb_image.h>

#include <algorithm>
#include <glm/gtc/type_ptr.hpp>
#include <iostream>
#include <numbers>
#include <span>
#include <vector>
static constexpr float POINT_LIFE = 30.0f;
static constexpr float SAMPLE_INTV = 0.05f;
static constexpr double G_CONST = 0.5;

CelestialBody::CelestialBody(double mass, const glm::dvec3 &initialPos,
                             const glm::dvec3 &initialVel, float scale,
                             const char *texturePath,
                             const glm::vec3 &trailColor)
    : mass_{mass}, pos_{initialPos}, vel_{initialVel}, scale_{scale},
      trailColor_{trailColor} {
    initMesh();
    initTrail();
    texture_.id = loadTexture(texturePath);
}

CelestialBody::~CelestialBody() noexcept = default;

void CelestialBody::updateTrail(float dt) {
    sampleAcc_ += dt;
    while (sampleAcc_ >= SAMPLE_INTV) {
        sampleAcc_ -= SAMPLE_INTV;
        trail_.push({glm::vec3(pos_), POINT_LIFE});
    }
    trail_.for_each([&](TrailPoint &tp) { tp.life -= dt; });
    rebuildTrailBuffer();
}

void CelestialBody::initMesh() {
    std::vector<float> vertices;
    std::vector<unsigned int> indices;
    constexpr int sectorCount = 36, stackCount = 18;
    constexpr float radius = 1.0f;

    for (int i = 0; i <= stackCount; ++i) {
        float stackAng = std::numbers::pi_v<float> / 2 -
                         i * std::numbers::pi_v<float> / stackCount;
        float xy = radius * std::cos(stackAng);
        float z = radius * std::sin(stackAng);
        for (int j = 0; j <= sectorCount; ++j) {
            float sectorAng = j * 2 * std::numbers::pi_v<float> / sectorCount;
            float x = xy * std::cos(sectorAng);
            float y = xy * std::sin(sectorAng);
            float u = float(j) / sectorCount;
            float v = float(i) / stackCount;
            vertices.insert(vertices.end(), {x, y, z, u, v});
        }
    }

    for (int i = 0; i < stackCount; ++i) {
        int k1 = i * (sectorCount + 1);
        int k2 = k1 + sectorCount + 1;
        for (int j = 0; j < sectorCount; ++j, ++k1, ++k2) {
            if (i != 0) {
                indices.push_back(k1);
                indices.push_back(k2);
                indices.push_back(k1 + 1);
            }
            if (i != stackCount - 1) {
                indices.push_back(k1 + 1);
                indices.push_back(k2);
                indices.push_back(k2 + 1);
            }
        }
    }

    indexCount_ = static_cast<GLsizei>(indices.size());

    glBindVertexArray(sphereVAO_.id);
    glBindBuffer(GL_ARRAY_BUFFER, sphereVBO_.id);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(float),
                 vertices.data(), GL_STATIC_DRAW);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, sphereEBO_.id);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int),
                 indices.data(), GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), nullptr);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float),
                          (void *)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);
    glBindVertexArray(0);
}

void CelestialBody::initTrail() {
    glBindVertexArray(trailVAO_.id);
    glBindBuffer(GL_ARRAY_BUFFER, trailVBO_.id);
    glBufferData(GL_ARRAY_BUFFER,
                 MAX_TRAILS * (sizeof(glm::vec3) + sizeof(float)), nullptr,
                 GL_DYNAMIC_DRAW);

    GLsizei stride = sizeof(glm::vec3) + sizeof(float);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, nullptr);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 1, GL_FLOAT, GL_FALSE, stride,
                          (void *)sizeof(glm::vec3));
    glEnableVertexAttribArray(1);
    glBindVertexArray(0);
}

void CelestialBody::rebuildTrailBuffer() {
    std::vector<float> data;
    data.reserve(trail_.size() * 4);
    trail_.for_each([&](const TrailPoint &tp) {
        float lf = std::max(tp.life / POINT_LIFE, 0.0f);
        data.push_back(tp.position.x);
        data.push_back(tp.position.y);
        data.push_back(tp.position.z);
        data.push_back(lf);
    });

    std::span<const float> span{data};

    glBindBuffer(GL_ARRAY_BUFFER, trailVBO_.id);
    glBufferSubData(GL_ARRAY_BUFFER, 0, span.size_bytes(), span.data());
}

unsigned CelestialBody::loadTexture(const char *path) noexcept {
    int w, h, n;
    stbi_set_flip_vertically_on_load(true);
    auto *img = stbi_load(path, &w, &h, &n, 0);
    if (!img) {
        std::cerr << "Failed to load texture: " << path << "\n";
        return 0u;
    }
    GLenum fmt = (n == 4 ? GL_RGBA : GL_RGB);
    glBindTexture(GL_TEXTURE_2D, texture_.id);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexImage2D(GL_TEXTURE_2D, 0, fmt, w, h, 0, fmt, GL_UNSIGNED_BYTE, img);
    glGenerateMipmap(GL_TEXTURE_2D);
    stbi_image_free(img);
    return texture_.id;
}

void CelestialBody::bindMeshAndTexture() const noexcept {
    glBindVertexArray(sphereVAO_.id);
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, texture_.id);
}

void CelestialBody::drawMesh() const noexcept {
    glDrawElements(GL_TRIANGLES, indexCount_, GL_UNSIGNED_INT, nullptr);
}

void CelestialBody::drawTrail() const noexcept {
    size_t n = trail_.size();
    if (n < 2)
        return;

    glBindVertexArray(trailVAO_.id);

    glDrawArrays(GL_LINE_STRIP, 0, static_cast<GLsizei>(n));
}



================================================
File: src/CelestialBody.h
================================================
#pragma once

#include "raii.h"
#include <glm/glm.hpp>

struct TrailPoint {
    glm::vec3 position;
    float life;
};

class CelestialBody {
  public:
    CelestialBody(double mass, const glm::dvec3 &initialPos,
                  const glm::dvec3 &initialVel, float scale,
                  const char *texturePath, const glm::vec3 &trailColor);
    ~CelestialBody() noexcept;

    void updateTrail(float dt);

    const glm::dvec3 &getPosition() const noexcept { return pos_; }
    const glm::vec3 &getTrailColor() const noexcept { return trailColor_; }
    float getScale() const noexcept { return scale_; }

    void bindMeshAndTexture() const noexcept;
    void drawMesh() const noexcept;
    void drawTrail() const noexcept;

    double getMass() const noexcept { return mass_; }
    glm::dvec3 getVelocity() const noexcept { return vel_; }
    void setPosition(const glm::dvec3 &p) noexcept { pos_ = p; }
    void setVelocity(const glm::dvec3 &v) noexcept { vel_ = v; }

  private:
    double mass_;
    glm::dvec3 pos_, vel_;
    float scale_;

    VertexArray sphereVAO_;
    Buffer sphereVBO_, sphereEBO_;
    Texture2D texture_;
    GLsizei indexCount_;

    VertexArray trailVAO_;
    Buffer trailVBO_;

    static constexpr size_t MAX_TRAILS = 1000;
    RingBuffer<TrailPoint, MAX_TRAILS> trail_;
    float sampleAcc_ = 0.0f;
    glm::vec3 trailColor_;

    void initMesh();
    void initTrail();
    void rebuildTrailBuffer();
    unsigned loadTexture(const char *path) noexcept;
};



================================================
File: src/GravityWell.cpp
================================================
#include "GravityWell.h"
#include "CelestialBody.h"

#include <cmath>
#include <glm/gtc/type_ptr.hpp>

GravityWell::GravityWell(float size, int resolution)
    : size_{size}, resolution_{resolution} {
    setupBuffers();
}

GravityWell::~GravityWell() noexcept = default;

void GravityWell::setupBuffers() noexcept {
    int N = 2 * resolution_ + 1;
    int totalLines = 2 * (N - 1) * N;
    vertexCount_ = totalLines * 2;
    cpuBuffer_.resize(vertexCount_ * 3);

    glBindVertexArray(vao_.id);
    glBindBuffer(GL_ARRAY_BUFFER, vbo_.id);
    glBufferData(GL_ARRAY_BUFFER, cpuBuffer_.size() * sizeof(float), nullptr,
                 GL_DYNAMIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), nullptr);
    glEnableVertexAttribArray(0);
    glBindVertexArray(0);
}

void GravityWell::updateFromBodies(const std::vector<CelestialBody *> &bodies,
                                   float G) noexcept {
    int N = 2 * resolution_ + 1;
    float step = size_ / resolution_;

    std::vector<float> yGrid(N * N);
    for (int j = 0; j < N; ++j) {
        for (int i = 0; i < N; ++i) {
            float x = (i - resolution_) * step;
            float z = (j - resolution_) * step;
            float y = 0.0f;
            for (auto *b : bodies) {
                auto p = b->getPosition();
                float dx = x - float(p.x);
                float dz = z - float(p.z);
                float d = std::sqrt(dx * dx + dz * dz + 0.1f);
                y += -G * float(b->getMass()) / d;
            }
            yGrid[j * N + i] = y;
        }
    }

    float *ptr = cpuBuffer_.data();
    for (int j = 0; j < N; ++j) {
        for (int i = 0; i < N - 1; ++i) {
            float x0 = (i - resolution_) * step;
            float x1 = (i + 1 - resolution_) * step;
            float z0 = (j - resolution_) * step;
            float y0 = yGrid[j * N + i];
            float y1 = yGrid[j * N + (i + 1)];

            *ptr++ = x0;
            *ptr++ = y0;
            *ptr++ = z0;
            *ptr++ = x1;
            *ptr++ = y1;
            *ptr++ = z0;
        }
    }
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N - 1; ++j) {
            float x0 = (i - resolution_) * step;
            float z0 = (j - resolution_) * step;
            float z1 = (j + 1 - resolution_) * step;
            float y0 = yGrid[j * N + i];
            float y1 = yGrid[(j + 1) * N + i];

            *ptr++ = x0;
            *ptr++ = y0;
            *ptr++ = z0;
            *ptr++ = x0;
            *ptr++ = y1;
            *ptr++ = z1;
        }
    }

    glBindBuffer(GL_ARRAY_BUFFER, vbo_.id);
    glBufferSubData(GL_ARRAY_BUFFER, 0,
                    static_cast<GLsizeiptr>(cpuBuffer_.size() * sizeof(float)),
                    cpuBuffer_.data());
}

void GravityWell::draw() const noexcept {
    glBindVertexArray(vao_.id);
    glDrawArrays(GL_LINES, 0, static_cast<GLsizei>(vertexCount_));
}



================================================
File: src/GravityWell.h
================================================
#pragma once

#include "raii.h"
#include <glm/glm.hpp>
#include <vector>

class CelestialBody;

class GravityWell {
  public:
    GravityWell(float size, int resolution);
    ~GravityWell() noexcept;

    void updateFromBodies(const std::vector<CelestialBody *> &bodies,
                          float G) noexcept;
    void draw() const noexcept;

  private:
    VertexArray vao_;
    Buffer vbo_;
    size_t vertexCount_;

    float size_;
    int resolution_;

    std::vector<float> cpuBuffer_;

    void setupBuffers() noexcept;
};



================================================
File: src/PhysicsEngine.cpp
================================================
#include "PhysicsEngine.h"
#include <cmath>

// Suzuki–Yoshida 4th-order symplectic integrator coefficients
namespace {
const double alpha = 1.0 / (2.0 - std::cbrt(2.0));
const double beta = -std::cbrt(2.0) / (2.0 - std::cbrt(2.0));
const double gamma = alpha;

const double d1 = alpha * 0.5;
const double d2 = (alpha + beta) * 0.5;
const double d3 = (beta + gamma) * 0.5;
const double d4 = gamma * 0.5;

const double k1 = alpha;
const double k2 = beta;
const double k3 = gamma;

std::vector<glm::dvec3>
getVelocities(const std::vector<CelestialBody *> &bodies) {
    std::vector<glm::dvec3> velocities(bodies.size());
    for (size_t i = 0; i < bodies.size(); ++i)
        velocities[i] = bodies[i]->getVelocity();
    return velocities;
}

void doDrift(std::vector<CelestialBody *> &bodies,
             const std::vector<glm::dvec3> &vels, double h) {
    for (size_t i = 0; i < bodies.size(); ++i) {
        glm::dvec3 r_old = bodies[i]->getPosition();
        bodies[i]->setPosition(r_old + vels[i] * h);
    }
}

void doKick(std::vector<CelestialBody *> &bodies,
            const std::vector<glm::dvec3> &accs, double h) {
    for (size_t i = 0; i < bodies.size(); ++i) {
        glm::dvec3 v_old = bodies[i]->getVelocity();
        bodies[i]->setVelocity(v_old + accs[i] * h);
    }
}
} // namespace

PhysicsEngine::PhysicsEngine() = default;
PhysicsEngine::~PhysicsEngine() = default;

void PhysicsEngine::addBody(CelestialBody *body) { bodies.push_back(body); }

const std::vector<CelestialBody *> &PhysicsEngine::getBodies() const {
    return bodies;
}

void PhysicsEngine::computeAccelerations() {
    size_t n = bodies.size();
    accelerations.resize(n);

    for (size_t i = 0; i < n; ++i) {
        glm::dvec3 a_i(0.0);
        glm::dvec3 r_i = bodies[i]->getPosition();

        for (size_t j = 0; j < n; ++j) {
            if (j == i)
                continue;

            glm::dvec3 r_j = bodies[j]->getPosition();
            double m_j = bodies[j]->getMass();

            glm::dvec3 diff = r_j - r_i;
            double dist2 = glm::dot(diff, diff) + 1e-15;
            double invDist3 = 1.0 / (dist2 * std::sqrt(dist2));

            a_i += (0.5 * m_j) * (diff * invDist3);
        }
        accelerations[i] = a_i;
    }
}

void PhysicsEngine::step(double dt) {
    if (bodies.empty())
        return;

    const size_t n = bodies.size();

    auto vel0 = getVelocities(bodies);
    doDrift(bodies, vel0, d1 * dt);

    computeAccelerations();
    auto a0 = accelerations;
    doKick(bodies, a0, k1 * dt);

    auto vel1 = getVelocities(bodies);
    doDrift(bodies, vel1, d2 * dt);

    computeAccelerations();
    auto a1 = accelerations;
    doKick(bodies, a1, k2 * dt);

    auto vel2 = getVelocities(bodies);
    doDrift(bodies, vel2, d3 * dt);

    computeAccelerations();
    auto a2 = accelerations;
    doKick(bodies, a2, k3 * dt);

    auto vel3 = getVelocities(bodies);
    doDrift(bodies, vel3, d4 * dt);

    for (auto *b : bodies)
        b->updateTrail(static_cast<float>(dt));
}



================================================
File: src/PhysicsEngine.h
================================================
#pragma once

#include "CelestialBody.h"
#include <glm/glm.hpp>
#include <vector>

class PhysicsEngine {
  public:
    PhysicsEngine();
    ~PhysicsEngine();

    void addBody(CelestialBody *body);
    void step(double dt);

    const std::vector<CelestialBody *> &getBodies() const;

  private:
    std::vector<CelestialBody *> bodies;
    std::vector<glm::dvec3> accelerations;

    void computeAccelerations();
};



================================================
File: src/Renderer.cpp
================================================
#include "Renderer.h"
#include "CelestialBody.h"

#include <format>
#include <fstream>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <sstream>
#include <stdexcept>

std::string Renderer::loadFile(const std::filesystem::path &path) {
    std::ifstream in{path, std::ios::binary};
    if (!in) {
        throw std::runtime_error(
            std::format("Failed to open shader file '{}'", path.string()));
    }
    std::ostringstream ss;
    ss << in.rdbuf();
    return ss.str();
}

Renderer::Renderer(int w, int h)
    : width_{w}, height_{h},
      bodyProg_{Program::fromSources(loadFile("shaders/vertex.glsl"),
                                     loadFile("shaders/fragment.glsl"))},
      trailProg_{Program::fromSources(loadFile("shaders/trail.vert"),
                                      loadFile("shaders/trail.frag"))},
      wellProg_{Program::fromSources(loadFile("shaders/gravitywell.vert"),
                                     loadFile("shaders/gravitywell.frag"))},
      gravityWell_{40.0f, 50} {
    glViewport(0, 0, width_, height_);
}

Renderer::~Renderer() noexcept = default;

void Renderer::setViewportSize(int w, int h) noexcept {
    width_ = w;
    height_ = h;
    glViewport(0, 0, width_, height_);
}

void Renderer::drawAll(const std::vector<CelestialBody *> &bodies,
                       const glm::mat4 &view, const glm::mat4 &proj) noexcept {
    glClearColor(0, 0, 0, 1);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    gravityWell_.updateFromBodies(bodies, 0.5f);
    wellProg_.use();
    {
        glm::mat4 mvp = proj * view;
        glUniformMatrix4fv(wellProg_.uniform("u_MVP"), 1, GL_FALSE,
                           glm::value_ptr(mvp));
    }
    gravityWell_.draw();

    bodyProg_.use();
    for (auto *b : bodies) {
        glm::mat4 model =
            glm::translate(glm::mat4{1.0f}, glm::vec3(b->getPosition())) *
            glm::scale(glm::mat4{1.0f}, glm::vec3(b->getScale()));

        glm::mat4 mvp = proj * view * model;
        glUniformMatrix4fv(bodyProg_.uniform("u_MVP"), 1, GL_FALSE,
                           glm::value_ptr(mvp));
        glUniform1i(bodyProg_.uniform("u_Texture"), 0);

        b->bindMeshAndTexture();
        b->drawMesh();
    }

    trailProg_.use();
    GLint locMvp = trailProg_.uniform("u_MVP");
    GLint locColor = trailProg_.uniform("u_TrailColor");
    for (auto *b : bodies) {
        glm::mat4 mvp = proj * view;
        glUniformMatrix4fv(locMvp, 1, GL_FALSE, glm::value_ptr(mvp));
        glUniform3fv(locColor, 1, glm::value_ptr(b->getTrailColor()));
        b->drawTrail();
    }
}



================================================
File: src/Renderer.h
================================================
#pragma once

#include "GravityWell.h"
#include "raii.h"
#include <filesystem>
#include <glm/glm.hpp>
#include <string>
#include <vector>

class CelestialBody;
class Renderer {
  public:
    Renderer(int width, int height);
    ~Renderer() noexcept;

    void drawAll(const std::vector<CelestialBody *> &bodies,
                 const glm::mat4 &view, const glm::mat4 &proj) noexcept;

    void setViewportSize(int width, int height) noexcept;

  private:
    int width_, height_;

    Program bodyProg_;
    Program trailProg_;
    Program wellProg_;
    GravityWell gravityWell_;

    static std::string loadFile(const std::filesystem::path &path);
};



================================================
File: src/main.cpp
================================================
#include "CelestialBody.h"
#include "PhysicsEngine.h"
#include "Renderer.h"

#include <GLFW/glfw3.h>
#include <backends/imgui_impl_glfw.h>
#include <backends/imgui_impl_opengl3.h>
#include <glad/glad.h>
#include <glm/gtc/matrix_transform.hpp>
#include <imgui.h>
#include <iostream>
#include <memory>

constexpr int WINDOW_WIDTH = 800;
constexpr int WINDOW_HEIGHT = 600;
constexpr float MOUSE_SENSITIVITY = 0.1f;
constexpr float CAMERA_SPEED = 5.0f;
constexpr float CAMERA_SPRINT_MULT = 5.0f;
constexpr float MAX_PITCH = 89.0f;

struct Camera {
    glm::vec3 position{0.0f, 0.0f, 30.0f};
    glm::vec3 front{0.0f, 0.0f, -1.0f};
    glm::vec3 up{0.0f, 1.0f, 0.0f};
    float yaw = -90.0f;
    float pitch = 0.0f;
    float lastX = WINDOW_WIDTH / 2.0f;
    float lastY = WINDOW_HEIGHT / 2.0f;
    bool firstMouse = true;
} camera;

float deltaTime = 0.0f;
float lastFrame = 0.0f;

void framebufferSizeCallback(GLFWwindow *window, int width, int height) {
    auto *renderer =
        reinterpret_cast<Renderer *>(glfwGetWindowUserPointer(window));
    if (renderer)
        renderer->setViewportSize(width, height);
}

void mouseCallback(GLFWwindow *window, double xpos, double ypos) {
    if (camera.firstMouse) {
        camera.lastX = (float)xpos;
        camera.lastY = (float)ypos;
        camera.firstMouse = false;
    }
    float xoffset = (float)xpos - camera.lastX;
    float yoffset = camera.lastY - (float)ypos;
    camera.lastX = (float)xpos;
    camera.lastY = (float)ypos;

    xoffset *= MOUSE_SENSITIVITY;
    yoffset *= MOUSE_SENSITIVITY;

    camera.yaw += xoffset;
    camera.pitch += yoffset;
    camera.pitch = glm::clamp(camera.pitch, -MAX_PITCH, MAX_PITCH);

    glm::vec3 direction;
    direction.x =
        cos(glm::radians(camera.yaw)) * cos(glm::radians(camera.pitch));
    direction.y = sin(glm::radians(camera.pitch));
    direction.z =
        sin(glm::radians(camera.yaw)) * cos(glm::radians(camera.pitch));
    camera.front = glm::normalize(direction);
}

void processInput(GLFWwindow *window) {
    float sprint = (glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)
                       ? CAMERA_SPRINT_MULT
                       : 1.0f;
    float camSpeed = CAMERA_SPEED * sprint * deltaTime;

    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
        camera.position += camSpeed * camera.front;
    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
        camera.position -= camSpeed * camera.front;
    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
        camera.position -=
            glm::normalize(glm::cross(camera.front, camera.up)) * camSpeed;
    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
        camera.position +=
            glm::normalize(glm::cross(camera.front, camera.up)) * camSpeed;
    if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS)
        camera.position += camSpeed * camera.up;
    if (glfwGetKey(window, GLFW_KEY_LEFT_CONTROL) == GLFW_PRESS)
        camera.position -= camSpeed * camera.up;
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);
}

int main() {
    if (!glfwInit()) {
        std::cerr << "Failed to initialize GLFW.\n";
        return -1;
    }
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 5);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    GLFWwindow *window =
        glfwCreateWindow(WINDOW_WIDTH, WINDOW_HEIGHT, "Three-Body Figure-Eight",
                         nullptr, nullptr);
    if (!window) {
        std::cerr << "Failed to create GLFW window.\n";
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);
    glfwSetCursorPosCallback(window, mouseCallback);
    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);

    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        std::cerr << "Failed to initialize GLAD.\n";
        glfwDestroyWindow(window);
        glfwTerminate();
        return -1;
    }

    glEnable(GL_DEPTH_TEST);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glEnable(GL_PROGRAM_POINT_SIZE);

    PhysicsEngine physics;
    Renderer renderer(WINDOW_WIDTH, WINDOW_HEIGHT);

    glfwSetWindowUserPointer(window, &renderer);
    glfwSetFramebufferSizeCallback(window, framebufferSizeCallback);

    constexpr double posScale = 20.0;
    constexpr double G_factor = 0.5;
    constexpr double mass = 100.0;
    double GM_over_L = (G_factor * mass) / posScale;
    double vScale = std::sqrt(GM_over_L);

    glm::dvec2 r1_orig = {-0.602885898116520, 0.059162128863347};
    glm::dvec2 r2_orig = {0.252709795391000, 0.058254872224370};
    glm::dvec2 r3_orig = {-0.355389016941814, 0.038323764315145};
    glm::dvec2 v1_orig = {0.122913546623784, 0.747443868604908};
    glm::dvec2 v2_orig = {-0.019325586404545, 1.369241993562101};
    glm::dvec2 v3_orig = {-0.103587960218793, -2.116685862168820};

    auto body1 = std::make_unique<CelestialBody>(
        mass, glm::dvec3(r1_orig.x, 0.0, r1_orig.y) * posScale,
        glm::dvec3(v1_orig.x, 0.0, v1_orig.y) * vScale, 0.5f,
        "textures/dirt.jpg", glm::vec3(1.0f, 0.0f, 0.0f));

    auto body2 = std::make_unique<CelestialBody>(
        mass, glm::dvec3(r2_orig.x, 0.0, r2_orig.y) * posScale,
        glm::dvec3(v2_orig.x, 0.0, v2_orig.y) * vScale, 0.5f,
        "textures/lava.png", glm::vec3(0.0f, 1.0f, 0.0f));

    auto body3 = std::make_unique<CelestialBody>(
        mass, glm::dvec3(r3_orig.x, 0.0, r3_orig.y) * posScale,
        glm::dvec3(v3_orig.x, 0.0, v3_orig.y) * vScale, 0.5f,
        "textures/stone.jpg", glm::vec3(0.0f, 0.4f, 1.0f));

    physics.addBody(body1.get());
    physics.addBody(body2.get());
    physics.addBody(body3.get());

    lastFrame = glfwGetTime();
    const double maxSubstep = 0.01;

    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO &io = ImGui::GetIO();
    (void)io;
    ImGui::StyleColorsDark();
    ImGui_ImplGlfw_InitForOpenGL(window, true);
    ImGui_ImplOpenGL3_Init("#version 450");
    while (!glfwWindowShouldClose(window)) {
        double now = glfwGetTime();
        double rawDt = now - lastFrame;
        lastFrame = now;
        deltaTime = (float)rawDt;

        processInput(window);

        double remaining = rawDt;
        while (remaining > 0.0) {
            double subDt = std::min(remaining, maxSubstep);
            physics.step(subDt);
            remaining -= subDt;
        }

        glm::mat4 view = glm::lookAt(camera.position,
                                     camera.position + camera.front, camera.up);
        int w, h;
        glfwGetFramebufferSize(window, &w, &h);
        glm::mat4 proj = glm::perspective(glm::radians(45.0f),
                                          (float)w / (float)h, 1.0f, 1000.0f);

        renderer.drawAll(physics.getBodies(), view, proj);

        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplGlfw_NewFrame();
        ImGui::NewFrame();

        ImGui::Begin("Performance");
        ImGui::Text("FPS: %.1f", 1.0f / deltaTime);
        ImGui::End();

        ImGui::Render();
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    glfwDestroyWindow(window);

    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplGlfw_Shutdown();
    ImGui::DestroyContext();
    glfwTerminate();
    return 0;
}



================================================
File: src/raii.h
================================================
#pragma once
#include <array>
#include <cstddef>
#include <glad/glad.h>
#include <stdexcept>
#include <string>
#include <utility>

struct GlObject {
    GlObject() = default;
    explicit GlObject(GLuint id) : id{id} {}
    ~GlObject() {
        if (id)
            glDeleteBuffers(1, &id);
    }
    GlObject(GlObject &&o) noexcept : id(o.id) { o.id = 0; }
    GlObject &operator=(GlObject &&o) noexcept {
        std::swap(id, o.id);
        return *this;
    }
    GLuint id = 0;
};

struct VertexArray : GlObject {
    VertexArray() { glGenVertexArrays(1, &id); }
    ~VertexArray() {
        if (id)
            glDeleteVertexArrays(1, &id);
    }
};
struct Buffer : GlObject {
    Buffer() { glGenBuffers(1, &id); }
    ~Buffer() {
        if (id)
            glDeleteBuffers(1, &id);
    }
};
struct Texture2D : GlObject {
    Texture2D() { glGenTextures(1, &id); }
    ~Texture2D() {
        if (id)
            glDeleteTextures(1, &id);
    }
};

template <class T, size_t N> class RingBuffer {
    std::array<T, N> buf_;
    size_t head_ = 0, count_ = 0;

  public:
    template <class F> void for_each(F f) {
        for (size_t i = 0; i < count_; ++i) {
            f(buf_[(head_ + i) % N]);
        }
    }

    template <class F> void for_each(F f) const {
        for (size_t i = 0; i < count_; ++i) {
            f(buf_[(head_ + i) % N]);
        }
    }

    void push(const T &item) {
        buf_[(head_ + count_) % N] = item;
        if (count_ < N)
            ++count_;
        else
            head_ = (head_ + 1) % N;
    }

    size_t size() const { return count_; }
    void clear() { head_ = count_ = 0; }
};

struct Program {
    Program() = default;
    explicit Program(GLuint id) : id{id} {}
    ~Program() noexcept {
        if (id)
            glDeleteProgram(id);
    }

    Program(const Program &) = delete;
    Program &operator=(const Program &) = delete;

    Program(Program &&o) noexcept : id(o.id) { o.id = 0; }
    Program &operator=(Program &&o) noexcept {
        std::swap(id, o.id);
        return *this;
    }

    void use() const noexcept { glUseProgram(id); }
    [[nodiscard]] GLint uniform(const char *name) const noexcept {
        return glGetUniformLocation(id, name);
    }

    GLuint id = 0;

    static Program fromSources(const std::string &vertSrc,
                               const std::string &fragSrc) {
        auto compile = [&](GLenum type, const std::string &src) {
            GLuint s = glCreateShader(type);
            const char *c = src.c_str();
            glShaderSource(s, 1, &c, nullptr);
            glCompileShader(s);
            GLint ok = 0;
            glGetShaderiv(s, GL_COMPILE_STATUS, &ok);
            if (!ok) {
                char buf[512];
                glGetShaderInfoLog(s, sizeof(buf), nullptr, buf);
                glDeleteShader(s);
                throw std::runtime_error(buf);
            }
            return s;
        };

        GLuint vs = compile(GL_VERTEX_SHADER, vertSrc);
        GLuint fs = compile(GL_FRAGMENT_SHADER, fragSrc);
        GLuint p = glCreateProgram();
        glAttachShader(p, vs);
        glAttachShader(p, fs);
        glLinkProgram(p);
        GLint ok = 0;
        glGetProgramiv(p, GL_LINK_STATUS, &ok);
        if (!ok) {
            char buf[512];
            glGetProgramInfoLog(p, sizeof(buf), nullptr, buf);
            glDeleteProgram(p);
            throw std::runtime_error(buf);
        }
        glDeleteShader(vs);
        glDeleteShader(fs);
        return Program{p};
    }
};



================================================
File: src/shaders/fragment.glsl
================================================
#version 450 core

in vec2 TexCoord;
out vec4 FragColor;

uniform sampler2D u_Texture;

void main() {
    FragColor = texture(u_Texture, TexCoord);
}




================================================
File: src/shaders/gravity_well.comp.glsl
================================================
#version 450
layout(local_size_x=8, local_size_y=8) in;

struct Body { vec3 pos; float mass; };
layout(std140, binding=0) readonly buffer Bodies {
  Body bodies[];
};

layout(std430, binding=1) buffer Heights {
  vec4 vertices[]; // x,y,z,unused
};

uniform float u_size;
uniform int   u_res;
uniform float u_G;

void main(){
  ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
  int N = 2*u_res + 1;
  if(gid.x >= N || gid.y >= N) return;
  int idx = (gid.y*(N-1) + gid.x)*2; // line‐grid layout...
  float step = u_size / float(u_res);
  float x = (float(gid.x)-u_res)*step;
  float z = (float(gid.y)-u_res)*step;
  float y = 0.0;
  for(int i=0;i<bodies.length();++i){
    Body b = bodies[i];
    vec2 diff = vec2(x,z) - b.pos.xz;
    float d = length(diff) + 0.1;
    y += -u_G * b.mass / d;
  }
  vertices[idx+0] = vec4(x, y, z, 0);
  vertices[idx+1] = vec4(x+step, /*…compute neighbor…*/, 0);
}



================================================
File: src/shaders/gravitywell.frag
================================================
#version 450
out vec4 FragColor;
void main() {
    FragColor = vec4(1.0,1.0,1.0,0.5); }



================================================
File: src/shaders/gravitywell.vert
================================================
#version 450
layout(location = 0) in vec3 aPos;
uniform mat4 u_MVP;
void main() {
    gl_Position = u_MVP * vec4(aPos, 1.0);
}



================================================
File: src/shaders/trail.frag
================================================
#version 450 core

layout(location = 0) in float v_LifeFrac;
out vec4 FragColor;

uniform vec3 u_TrailColor; 
void main() {
    float alpha = clamp(v_LifeFrac, 0.0, 1.0);
    FragColor = vec4(u_TrailColor, alpha); 
}




================================================
File: src/shaders/trail.vert
================================================
#version 450 core

layout(location = 0) in vec3 a_Pos;
layout(location = 1) in float a_LifeFrac;
layout(location = 0) out float v_LifeFrac;
uniform mat4 u_MVP;

void main() {
    v_LifeFrac  = a_LifeFrac;
    gl_Position = u_MVP * vec4(a_Pos, 1.0);
}




================================================
File: src/shaders/vertex.glsl
================================================
#version 450 core

layout(location = 0) in vec3 aPos;
layout(location = 1) in vec2 aTexCoord;

uniform mat4 u_MVP;

out vec2 TexCoord;

void main() {
    gl_Position = u_MVP * vec4(aPos, 1.0);
    TexCoord = aTexCoord;
}




================================================
File: src/textures/AngerBeta.webp
================================================
[Non-text file]


================================================
File: src/textures/lava.webp
================================================
[Non-text file]


================================================
File: src/textures/stone.webp
================================================
[Non-text file]

